{% extends "base.html" %}

{% block content %}


<br>
<h2> Welcome to the documentation for the experimental monitor web suite </h2>
<hr>
<h3>Getting Started</h3>
<br>
<p>
As a user you can do several things: start and stop data-taking, monitor the data coming in, 
monitor the acquisition computer cluster, browse runs, and view the logs.
 </p>
 <p>Most of these actions are possible as a normal user. However to take control of the DAQ 
 you have to elevate your permissions in your profile. You can navigate to your profile on 
 the top right of the page. Please follow the instructions there.
 </p>
 <br>
<h3>Development</h3>
<br>
<p>If you're interested in developing new functionality please contact the DAQ group. The site
is implemented in Django with a SQL-lite backend. However all acquisition monitoring information 
is provided by a MongoDB database. If you have a cool idea for a new view you are welcome to 
implement it!
</p>
<br>
<h3>MongoDB Document format</h3>
<br>
<p> The DAQ system is synchronized by a MongoDB backend. The same backend is used to communicate
with the web interface. This relies on certain formats being followed. And new collections made
 should be documented here.
</p>
<br>
<h4>Run Control Docs</h4>
<p>The run control doc has the following form:</p>
<pre class="prettyprint">
doc:{
		"runmode": string,
		"user": string,
		"name": string,
		"detector": string,
		"shorttype": string,
		"starttimestamp": datetime,
		"endtimestamp": datetime,
		"trigger": {
			"mode" : string,
			"status": string,
			"ended": string,		
		},
		"reader": {
			"options": ini_file_as_string,
			"compressed": int,
			"starttime": int,
			"endtime": int,
			"data_taking_ended": bool,
			"storage_buffer": {
				"dbname": string,
				"dbcollection": string,
				"dbaddr": string,
		},
		"processor": {
			"mode": string,
		},
		"comments": [
			{ 
				"user": string,
				"date": datetime,
				"text": string,
			},
		],
	} 
</pre>
<br>
<p>The default collection for run docs is 'online.runs'.
</p>
<h4>Dispatcher Status Docs</h4>
<p>The dispatcher inserts the following status docs into online.status every couple seconds:</p>
<pre class="prettyprint">
doc:{
	"createdAt": datetime,
	"timeseconds": int,
	"detector": string,
	"mode": string,
	"state": string,   		// "Running", "Idle", "Armed", "Error", "Undefined"
	"network": bool,
	"currentRun": string,
	"startedBy": string,
	"startTime": string,
	"numSlaves": int,
}
</pre>
<br><p>
This doc is a global status. In addition to the status updates of each slave node 
are inserted in the database as they are received. This is a TTL collection and the
documents are deleted after a certain time. This allows the user to look back in time
a little bit to see how each node has been behaving. These docs are put into online.nodes.
<pre class="prettyprint">
doc:{
	"createdAt": datetime,
	"node": string,
	"bltrate": int, // rate of block transfers
	"datarate": float, // rate in MB/s
	"runmode": string,
	"nboards": int,
	"timeseconds": int,
}
</pre>
<br>
<h4>Log Entry Docs</h4>
<p>All DAQ components are capable of making log entries. Users can make log entries via 
the interface as well. These entries are threaded. Log entries tagged as ERROR or FATAL
require user intervention in order to continue operating the DAQ. The log is at online.log.</p>
<pre class="prettyprint">
doc: {
	"message": string,
	"time": datetime,
	"sender": string,
	"priority": int,
}
</pre>
<br><p>
The possible priority tags are: USER (0), INFO (1), WARNING (2), ERROR (3), FATAL(4), 
WARNING_CLOSED (7), ERROR_CLOSED (8), FATAL_CLOSED (9), DEBUG(99). If there are any entries in the 
log with WARNING, ERROR or FATAL tags, the user will be advised. Additionally for ERROR 
and FATAL tags, run start is disabled until a user responds to them. The user responds 
by filling out a response form on the log page informing what action was taken. This is 
stored in a thread with the log message and the tag is switched to 'closed'.
</p>
<br>
<h4>Command and Reply Docs</h4>
<p>The ability to control the acquisition system over the web interface means the user 
has to be able to send commands. The commands are limited to 'start' and 'stop' for the 
system. Any further action has to be undertaken by experts in the backend. In addition to 
the command docs there are reply docs. After a user issues a command it has to pass a plausibility 
check by the web server. If this passes the server passes the request to the database where 
it is picked up by the dispatcher. An additional plausibility check is performed and the result 
is reported back. If the result is positive the run is started, if it is negative the run is 
not. A third option exists where the DAQ might issue a warning but allow a start anyway. In 
this case the user will be shown the warning and given the option to override or not.
</p>
<p>The initial command doc has the following format:</p>
<pre class="prettyprint">
doc: {
	"command": string,	// command string
	"mode": string,		// run mode if start command
	"name": string,		// user name
	"comment": string,	// comment for starting or stopping run
	"detector": string,	// which detector to apply (ALL means all)
	"baselines": bool,	// perform baselines (for run start)
	"noise": bool,			// make noise spectra (for run start)
}
</pre>
<br>
<p>The reply has the following format:</p>
<pre class="prettyprint">
doc:{
	"replyenum": int,     // Response code. 
	"message": string,
	"mode": string,
	"user": string,		// Requesting user
}
</pre>
<br><p>
Here the replyenum is one of the following: SUCCESS (0), FAILED (1), STATUS (2), OVERRIDE (3). 
In all cases the message string contains more information. These docs are placed into online.daqcommands.
In addition to the command docs a 'lock' document also exists. The lock document looks like this:
</p>
<pre class="prettyprint">
doc:{
	"lock": bool,     	// If there is a lock 
	"lock_user": string, // The user who made the lock
	"lock_time": string, // The time the lock was made
}
</pre>
<br><p>
The locking document is checked whenever a user makes a command. If it is locked it means the DAQ is 
busy with another command. In case of a lock error the user will have the option to override the lock. 
Locks are made by the web interface as soon as the user's command is accepted. They are freed by the 
dispatcher as soon as the DAQ finishes with the command. Locks expire be default after one minute.
</p>
<br>
<h4>Run Configuration Docs</h4>
<p>
The digitizers read a local ini file to start running. This ini file can be created by the DAQ dispatcher from a BSON
document (but it's basically JSON because we have no binary fields).
This allows run modes to be stored on the web database and viewed or modified by the frontend. During commissioning
the run configuration document will probably change as fields are added, modified, or removed. However this should stabilize later.

Normal users can view operations modes. Superusers can edit the JSON directly in their browser.
</p>
	<pre class="prettyprint">
doc = {
	"user": string, 					# Who made the document
	"created": datetime,				# when was it made
	"name": string,						# long name of doc, ambe_run10_mod0, for example
	"shortname": string,				# name for run badges, for example just "AmBe". Max 5-6 characters
	"detector": string,					# name of the detector this doc is for
   	"blt_size": 524288,
   	"run_start": 1,
	"run_start_module": 1868,
	"muon_veto": 0,                     # NIM for S-IN prop to MV or not
	"pulser_freq": 0,                   # 0 inactive
	"write_mode": 0,                    # 0 -none, 1-file, 2-MongoDB
	"compression": 1,                   # 0 -none, 1-snappy
	"baseline_mode": 1,                 # 0 -load from file, 1-run start, 2-none
	"processing_num_threads": 8,        # Number of processing threads
	"processing_mode":  4,              # Parsing mode: 0-none, 1-event, 2-occurrence, 3-occurrenceZLE, 4-new FW
	"processing_readout_threshold": 1,  # # of BLTs that must be in board buffer before it's read
	"occurrence_integral": 0,           # Integrate each pulse (! Only processing modes 2,3,4) 0-off, 1-on
	"file_path": "",
	"file_events_per_file": 1000000,
	"mongo_address": "xedaq00",
	"mongo_database": "raw",
	"mongo_collection": "data*",
	"mongo_write_concern": 0,           # 0- No write concern, 1- on
	"mongo_min_insert_size": 1,         # minimum size of BSON vector for bulk inserts
	"trigger_mode"	: string,			# mode for the trigger. Should be something the trigger understands
	"processing_mode": string,			# mode for the processor. ditto
	"registers": [
		{
			"register": "EF24",
			"value": "0",
			"board": "-1",
			"comment": "board reset register"
		},
		{
			"register": "EF1C",
			"value": "1",
			"board": "-1",
			"comment": "events per BLT"
		},
		{
			"register": "EF00",
			"value": "10",
			"board": "-1",
			"comment": "BERR register, 10=enable BERR",
		},
		{
			"register": "8100",
			"value": "0",
			"board": "-1",
			"comment": "acquisition control register. Always set to 0"
		},
	],
	"DDC-10": {
		"address": "130.92.139.240",
		"sign": 1,
		"window": 100,
		"delay": 200,
		"signal_threshold": 150,
		"integration_threshold": 20000,
		"width_cut": 50,
		"rise_time_cut": 30,
		"component_status": 1,
		"parameter_0": 0,
		"parameter_1": 0,
		"parameter_2": 0,
		"parameter_3": 50,
		"outer_ring_factor": 2,
		"inner_ring_factor": 1,
		"prescaling": 1000,
	},
	"links": [
		{
			"type": "V2718",
			"link": 0,
			"crate": 0,
			"reader": 0,
		},
		{
			"type": "V2718",
			"link": 0,
			"board": 0,
			"reader": 1,
		}
	],
	"boards": [
		{
			"type": "V1724",
			"link": 0,
			"board": 0,
			"vme_address": "32100000",
			"serial": "876",
			"reader": 0,
		},
		{
			"type": "V1724",
			"link": 0,
			"board": 0,
			"vme_address": "22230000",
			"serial": "770",
			"reader": 1,
		},
	]
}
</pre>
<br><p>
These docs go in the collection "online.run_modes". The a run is started the entire ini file is written to the run document
in string form (string for maintains compatibility in case a run is started via command line with a traditional ini file).
</p>
<h3>Data Monitoring</h3>
<p>
The data monitor has two types of documents. "Event documents" contain data on single events. During operation a pax instance
processes data from the trigger output database and fills a capped MongoDB collection with event docs. This means there is a buffer
of event docs. The buffer is managed such that new event docs are always added as quickly as they can be processed. When the
collection reaches a certain size the old docs are deleted.

The other type of document are "aggregate documents". These are basically histograms in the form of MongoDB documents. This
is an online view of certain detector properties. These documents are filled on a per-run basis (when a new run comes along
the old doc is retired and a new one is created). So the user is able to view these aggregate histograms for the most recent run,
the last week, or the entire data period. These aggregate documents have a general form so that new aggregates can be added to
pax at any time and the frontend will know what to do with them.
</p>

<p>
The aggregate docs have the following form:
</p>
	<pre class="prettyprint">
doc = {
	"name": string,   			# name of the histogram
	"type": string,				# type of aggregate, currently supports h1, h2, scatter
	"run":	string,				# name of the run for which this histgram is valid
	"xaxis": {
		"label": 	string,		# name of the x axis
		"start": 	float,		# starting value of first bin (only h1/h2)
	},
	"yaxis": {
		"label":	string,		# name of the y axis
		"start": 	float,		# starting value of the first bin (only h1/h2)
	},
	bulk:[	float ],			# list of bin contents, in case of n dimensions [float,float] = [x,y]
}
</pre>
<p>
The event docs are basically a mirror of the pax3 event class, containing all waveforms and found peaks.
</p>
<pre class="prettyprint">

</pre>

{% endblock %}